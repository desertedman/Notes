# 1. A Tour of Computer Systems

<!--toc:start-->

- [1. A Tour of Computer Systems](#1-a-tour-of-computer-systems)
  - [C Source Code -> Executable Program](#c-source-code-executable-program)
  - [Hardware Overview](#hardware-overview)
  - [Execution of a Program](#execution-of-a-program)
  - [Memory Hierarchy](#memory-hierarchy)
  - [Operating System Role](#operating-system-role)
  - [Networks](#networks)
  - [Big Ideas](#big-ideas)
  <!--toc:end-->

## C Source Code -> Executable Program

- C program goes through four steps before it runs:
  1. **Preprocessing**: handles `#include`, `#define` macros
  2. **Compilation**: translates C -> assembly
  3. **Assembly**: assembler turns assembly -> machine code (.o file)
  4. **Linking**: combines multiple object files + libraries -> final executable

## Hardware Overview

- Buses - High-speed channels connecting components
  - Transfers fixed-size chunks known as words
- I/O Devices - Keyboard, mouse, display, disk - communicate via controllers
- Main Memory (RAM) - Temporary storage for programs + data
- Processor (CPU) - Fetches and executes instructions. Contains:
  - PC (program counter) - Address of current instruction
  - Registers - Small, fast storage
  - ALU - Arithmetic/logic

## Execution of a Program

- Steps when running a program
  1. Shell loads program into memory
  2. CPU fetches instruction into PC
  3. Instructions execute one by one (load, compute, store)
  4. Program prints text to screen via I/O

## Memory Hierarchy

- Organizes storage by speed vs. size vs. cost:
  - Registers (fastest, smallest)
  - Caches (small but very fast SRAM)
  - Main Memory (RAM)
  - Disk/SSD (large but slow)
- Programs run faster by exploiting **locality** (reuse data/code in nearby memory locations)

## Operating System Role

- OS provide abstractions between programs and hardware
  - Processes: illusion of multiple programs running at once
  - Virtual Memory: each program thinks it has its own memory space
  - Files: uniform way to access disks, keyboards, networks

## Networks

- Machines connected by networks (LAN, WAN, Internet)

## Big Ideas

- Abstraction - Hiding complexity (files, virtual memory, processes)
- Concurrency - Many things happening at once (multi-core CPUs, threads)
- Parallelism - Speeding things up with multiple compute units
- Locality - Programs are fast if they reuse nearby instructions/data
